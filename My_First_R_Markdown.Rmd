---
title: "My first R Markdown"
author: "Rudy Rupp"
date: "21/08/2020"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Data Scientist's Toolsbox Week 1
 **What is Data Science?**
 0:43 - 0:56
  They state that a data scientist is broadly defined as someone who combines the skills of software programmer, statistician, and storyteller/artists to extract the nuggets of gold hidden under mountains of data.


# Data Scientist's Toolsbox Week 2
 **R Studio tour**  
 
```{r}
matrix(c(1, 2, 3, 4, 5, 6, 7, 8), nrow = 4, ncol = 2)
```

### R Packages  

 **Installing from CRAN**  
 If you are installing from the CRAN repository, use the *install.packages()*  function, with the name of the package you want to install in quotes between the parentheses (note: you can use either single or double quotes). For example:  

 *install.packages("ggplot2")*  

 To install multiple packages at once, you can do so by using a character vector:   
 *install.packages(c("ggplot2", "devtools", "lme4"))*  
 
 
 **Installing from Bioconductor**  
 The BioConductor repository uses their own method to install packages. First, to get the basic functions required to install through BioConductor, use:  
 
 *source("https://bioconductor.org/biocLite.R")*  
 
 This makes the main install function of BioConductor, *biocLite()*, available to you. Following this, you call the package you want to install in quotes, between the parentheses of the biocLite command, like so:  
 
 *biocLite("GenomicFeatures")*  
  
 **Installing from GitHub **  
 You first must find the package you want on GitHub and take note of both the package name AND the author of the package. Check out [this guide](http://kbroman.org/pkg_primer/pages/github.html) for installing from GitHub:  
 
 - *install.packages("devtools")* - only run this if you don’t already have devtools installed.  
 - *library(devtools)* - loads the devtools package  
 - *install_github("author/package")* replacing “author” and “package” with their GitHub username and the name of the package.  

 **Loading packages**  
 Installing a package does not make its functions immediately available to you. First you must load the package into R; to do so, use the *library()* function. For example:  
```{r}
 library(ggplot2)
```

NOTE: Do not put the package name in quotes! Unlike when you are installing the packages, the *library()* command does not accept package names in quotes!  

 **Checking what packages you have installed**  
 *installed.packages()* or *library()* with nothing between the parentheses to check.  

 **Updating packages**  
 old.packages() identify packages that have been updated since last updated.  
 To update all packages, use update.packages(). If you only want to update a specific package, use install.packages("packagename")  

 **Unloading packages**  
 To unload a given package you can use the detach() function. For example, *detach("package:ggplot2", unload=TRUE)*  

 **Uninstalling packages**  
 If you no longer want to have a package installed, you can simply uninstall it using the function remove.packages(). For example, *remove.packages("ggplot2")*  

 **How do you know what version of R you have?**  
 Type *version* into the console and it will output information on the R version you are running.  
 *sessionInfo()* - will tell you what version of R you are running along with a listing of all of the packages you have loaded. The output of this command is a great detail to include when posting a question to forums - it tells potential helpers a lot of information about your OS, R, and the packages that you are using.  

 **What commands are included in a package?**  
 You can use the *help()* function to access a package’s help files.  
```{r}
help(package = "ggplot2")
```
 
 If you still have questions about what functions within a package are right for you or how to use them, many packages include “vignettes.” These are extended help files, that include an overview of the package and its functions, but often they go the extra mile and include detailed examples of how to use the functions in plain words that you can follow along with to see how to use the package. To see the vignettes included in a package, you can use the *browseVignettes()* function.  
 Eg: *browseVignettes("ggplot2")*


 You should see that there are two included vignettes: “Extending ggplot2” and “Aesthetic specifications.” Exploring the Aesthetic specifications vignette is a great example of how vignettes can be helpful, clear instructions on how to use the included functions.


# Data Scientist's Toolsbox Week 3 

 **Version control (Git & GitHub) Vocabulary**

 - **Repository** online folder that contains the whole, shared project
Commit to save your changes locally, and add explanations of what has been changed.  
 - **Push** upload changes made locally to the repository, and merge them.  
 - **Pull** download the most recent changes from the repository and merge with your local folder.  
 - **Staging** to commit files separately and add separate explanations to each section edited, in order to simplify looking at the change log.  
 - **Branch** your local files and edits, before you push them.  
 - **Merge** independent branches are joined together into a single file. May need manual control if the same section of the same file was edited differently in both branches.  
 - **Conflict** when branches have been edited in the same section and file, making automatic merging hard.  
 - **Clone** make a local copy of a whole Git repository’s files and all the change history.  
 - **Fork** make a personal copy of a repository that doesn’t affect the original.  

 **Best Practices:**  
 
 - Purposeful, single issue commits  
 - Informative commit messages  
 - Pull and Push often  
 
 
 - Git username Rodrupp  
 - Git email rodrupp@gmail.com  
 - Git password: automatically generated on firefox.  

 **Linking an Existing Project with GitHub**
 Open Git Bash or Terminal and navigate to the directory containing your project files. Move around directories by typing cd ~/dir/name/of/path/to/file  
 Once here, type *git init* followed by *git add .* -> this initializes (init) this directory as a git repository and adds all of the files in the directory (.) to your local repository. Commit these changes to the git repository using *git commit -m "Initial commit"* 

 Go to GitHub.com, and again, create a new repository:  
 
 - 1) Make sure the name is the exact same as your R project;  
 - 2) Do NOT initialize a README file, .gitignore, or license.  

 Find *“...push an existing repository from the command line”* and copy to clipboard. 
 Paste these into the Terminal, then reload the repository page.
 
 
# Data Scientist's Toolsbox Week 4
 
## R Markdown Example
 
This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

## R Markdown formatting

To bold text use double asterisks **bold**.  

to make it italics use single asterisks *italics*.  

to strikethrough text use double tildes ~~strikethrough~~  

Use # for headings: 
 - # Biggest Header  
 - ## Second biggest  
 - ### Third heading 

Code boxes created with triple backdash ``` 
```{r}
print("Testing some code here.")
```

```{r}
print("testing the keyboard shortcut ctrl+alt+i")
```

```{r}
print("testing the insert button on RStudio")
print("testing multiple lines of code.")
print("and here is the third line")
```

Use Ctrl+enter to run a line of code in RStudio without having to knit the document.  
Use Ctrl+shift+enter to run all lines in a chunk. 

Making bulletted lists:  

 - bullets must finish with two spaces  
 - this is an example  
 - i wonder what happens if i don't include two spaces?  
 - ok, here goes: 
 - did it work?  
 -- indent bullets with a double dash  
 
 [This is a link to google](http://www.google.com/)
 
 
### Types of Data Analysis  
 
 1) Descriptive  
 2) Exploratory  
 3) Inferential  
 4) Predictive  
 5) Causal  
 6) Mechanistic  
 
 **Descriptive** 
 Describes or summarises a set of data. 
 Often the first analysis to perform. eg mean, standard deviation, etc.
 
 **Exploratory Analysis** 
 Examine data and find new relationships. 
 Help formulate hypotheses and drive future studies.
 
 **Inferential Analysis** 
 Use a small sample of data do infer something about a larger population
 provides estimate and uncertainty. Depends on your sampling.
 
 **Predictive Analysis** 
 Use current data and historical data to make predictions. Dependent on measuring the right variables. More data and simple model is usually better.
 
 **Causal Analysis** 
 See what happens to one variable when we manipulate another. Gold standard in data analysis. Often applied to randomized studies designed to identify causation. Often challenging to obtain data.
 
 **Mechanistic Analysis** 
 Understant the exact changes in variables that lead to exact changes in other variables. Less common and more complex. Applied to simple situation or those that are nicely modeled by deterministic equations (eg physics or engineering). 
 
### Experimental Design
 
 Experimental design is organizing an experiment, so that you have the correct data and enough of it to clearly and effectively answer your data science question. 

 In this order:  
 
 1) Formulate your question before collecting any data  
 2) Design the experiment.  
 3) Identify problems.  
 4) Collect data.  
 
 And then a bunch of stuff I already know...  
 
### Big Data
 
 Volume, Velocity, Variety, Unstructured  
 
 Examples: Text files and documents, Websites and applications, Sensor data, Image Files, Audio files, Video files, Email Data, Social Media data.  
 
**Before you can start looking for answers, you need to turn your unstructured data into a format that you can analyze.**  
 
 
# R Programming Week 1  

**Learning Objectives**  
 - Install R Stoduio and Packages, including Swirl  
 - History of R and S  
 - describe differences between atomic data types  
 - Subset R objects using "[", "[[" and "$"  
 - Understand coersion, implicit and explicit  
 - Remove NAs from objects  

## Setting values  
```{r}
x <- 1  ##sets the value of x to 1
x  ## prints the value of x
```

```{r}
msg <- "hello"  ##gives msg the text "hello"
msg ## prints the text set to msg
```
 You can also set calculations into the value  
```{r}
x <- x+1 ##Increases the value of x by one.
y <- 5
z <- x+y
print(z)
```  

The result of the expression may be auto printed.  
```{r}
x <- 5 ## nothing pinter
x  ## auto-printing occurs
print(x)  ## explicit printing
```  

A vector may also be set for a variable
```{r}
x <- 1:20  ## creates an integer sequence from 1 to 20
x
```  

Calculations can also be applied on vectors
```{r}
x <- 1:20 
y <- x*3
y 
```  

## Objects and Attributes  

R has 5 basic or "atomic"classes of objects  
 - character (text)  
 - numeric (real numbers, ie decimal numbers)  
 - integer  
 - complex  
 - logical (true/false)  
 
The most basic object is a vector.  
 - Vectors can contain only objects of the same class  
 - except *lists*  
 
Empty vectors can be created with the vector() function. It has 2 arguments: the class of the object and the length of the vector.

### Numbers  
Typically treated as numeric objects (Even if "1" is entered, it is understood as "1.0000000000").  You can enter 1L to explicitly make it an integer.

*Inf* can be used as a number for infinity. *-Inf* also possible  
*NaN* can be used as a missing or undefined value, e.g 0/0  

### Attributes  
Objects can have attributes such as:  
 - names, dimnames  
 - dimensions (eg matrices and arrays)  
 - class  
 - length (the length of a vector is the number of elements in the vector)  
 - other, user-defined attributes  
 
 Attributes can be accessed using the *attributes()* function.  
 
## Vectors and Lists  
The c() function can be used to create vectors. c can stand for concatonate.  
```{r}
x <- c(0.5, 0.6)  ## numeric 
y <- c(T, F)   ## logical 
z <- c("a", "b", "c")  ## character 
w <- 9:29  ## integer
v <- c(1+0i, 2+4i)  ## complex

print(c(x,y,z,w,v))
```  

Or use vector function:  
```{r}
x <- vector("numeric", length = 10)
x
```  
By default for numeric vectors, the value is 0.

### Mixing Objects  
Objects can be forced into a different class. You won't get an error message.  
```{r}
x <- c(1.7, "a")  ## all will be treated as characters / text
x
y <- c(TRUE, 2)  ## all will be treated as numeric. T = 1, F = 0
y
z <- c("a", TRUE)  ## all will be treated as characters / text
z
```  

You can explicitly coerce objects into another class.  
```{r}
x <- 0:6
class(x)
as.numeric(x)
as.logical(x)
as.character(x)
as.complex(x)
```  

Nonsensical coercion results in NAs  
```{r}
x <- c("a", "b", "c")
as.numeric(x)
as.logical(x)
as.complex(x)
```  

### Lists
Can contain objects of different classes. Elements are encased in double brackets. 
```{r}
x <- list(1, "a", TRUE, 1+4i)
x
```  

## Matrices  
Are vectors with a *dimension* attribute.
```{r}
m <- matrix(1:6, nrow = 2, ncol = 3)
m
dim(m)    ## gives dimensions of matrix, rows and columns
attributes(m)   ## shows attribute dim 
```  
**Matrices get constructed column-wise, top to bottom.**

Matrices can be made from normal vectors
```{r}
m <- 1:10
m
dim(m) <- c(2,5)  ## adds the dimension attribute to it, while assigning a value to 
 ## the dim attribute of m: the number of rows and columns.
m
```

Making matrices by column binding or row binding:  
```{r}
x <- 1:3
y <- 10:12
cbind(x, y)
rbind(x, y)
```  

## Factors  
Used to represent categorical data. Ordered or unordered. You could think of a factor as an integer vector where each integer has a label. Eg: 1 - high; 2 - medium; 3 - low. 
They are treated specially by modeling functions like *lm()* and *glm()*. They are better than using integers because they are self-descriptive.
```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"))
x
table(x)  ## counts how many of each level
unclass(x)  ## removes the class of the vector, shows integer values

```  

The order of the levels of the factor is set in alphabetical order. between "yes" and "no", No will be the baseline level. You can explicitly change this with the *level()* function. 
```{r}
x <- factor(c("yes", "yes", "no", "yes", "no"), 
            levels = c("yes", "no"))
x
```  

## Missing Values  
Denoted by NA "Not Available" (or NaN "Not a Number", for undefined mathematical operations).  
 - *is.na()* and *is.nan()* used to test objects.  
 - NA values can have classes also, eg Integer NA, character NA, etc.  
 - NaN value is also NA, but converse is not true  
```{r}
x <- c(1, 2, NA, 10, 3)
is.na(x)
is.nan(x)
x <- c(1, 2, NaN, NA, 4)
is.na(x)
is.nan(x)
```  

## Data Frames  
Used to store tabular data.
 - represented as a special type of list, but each element of the list has to have the same length.  
 - each element of the list is a column, and the length of each element is the number of rows.  
 - they can store different classes of objects in each column, which makes them different from matrices.  
 - special attribute called *row.names*  
 - usually created with *read.table()* or *read.csv()* or *data.frame()*  
 - can be converted into matrices with *data.matrix()*  (will coerce objects into being the same class)  

```{r}
x <- data.frame(foo = 1:4, bar = c(T, T, F, F))
x
nrow(x)
ncol(x)
```  

## Names Attribute  
Important for writing readable code and self describing objects.  
```{r}
x <- 1:3
names(x)
names(x) <- c("foo", "bar", "norf")
x
names(x)
```  

List names and matrix names:  
```{r}
x <- list(a = 1, b = 2, c = 3)
x

m <- matrix(c("BB", "Bb", "Bb", "bb"), nrow = 2, ncol = 2)
dimnames(m) <- list(c("B", "b"), c("B", "b"))  ##row names, then column names
m
```  


## Reading Tabular Data  
Principal functions  
 - *read.table()*, *read.csv()* read text files in rows and columns and return a data frame in R  
 - *readLines()* reads lines of a text file, gives a character vector  
 - *source()* read R code files  
 - *dget()* read R files: objects that are "deparsed"  
 - *load()* reading binary objects into R  
 - *unserialize()* also for binary objects  
 
Analogous functions for writing data, in order:  
 - *write.table()*  
 - *writeLines()*  
 - *dump()*  
 - *dput()*  
 - *save()*  
 - *serialize()*  
 
### Reading files with read.table()  
Examine *?read.table* help file. Creates a **data frame** from a file in table format. Common arguments:  

 - *file* name of file / path to file  
 - *header* indicates if the first line is a header or not  
 - *sep* indicates how columns are separated  
 - *colClasses* character vector of the same length as number of columns. Indicates class of each column (can be different for each column).  
 - *nrows* number of rows (not required)  
 - *comment.char* indicates what character indicates comments  
 - *skip* skips a number of lines  
 - *stringsAsFactors* default=true, are character variables encoded as factors?  

for moderately sized datasets, you can call read.table without any arguments other than *file*. R will automatically:  
 - skip lines that begin with #  
 - find number of rows  
 - classify variables  
 
 However, giving R these arguments will make it runs more smoothly and predictably. *read.csv()* is an identical command except that the default separator is a comma instead of a space. CSV files are common outputs from excel files and many other programs.  

### Reading Larger Datasets with read.table  
Things to do to facilitate reading.  
 - Read the Help page carefully for read.table
 - Make a rough calculation of the memory required to store your dataset. Is it larger than the RAM on your computer? If so don't proceed.  
 - Set *comment.char = " "* if there are no commented lines in your file.  
 - use the colClasses argument. Specifying this option instead of using the default. R won't need to try to figure it out. If all classes are the same class you can set them all with *colClasses = "numeric"* for example. Alternatively, use the first 100 rows and let read.table find the classes, then apply them to reading the whole text:  
```{r}
initial <- read.table("datatable.txt", nrows = 100)
classes <- sapply(initial, class)  ## S apply calls the class of each column
tabAll <- read.table("datatable.txt", colClasses = classes)
```  
 - set *nrows* to help reduce memory usage. a mild overestimate is okay.  
 
It's useful to know a few things:  
 - How much memry is available?  
 - what other applications are in use?  
 - are other users using resources of the computer?  
 - what operating system are you using?  is it 32 or 64 bit?  

### Calculating Memory Requirements  
Consider a data frame with 1,500,00 rows and 120 columns, all of which are numeric data. How much memory is required?  

each numeric object required 8 bytes, stored in 64 bits of data.  

1,500,00 x 120 x 8 bytes/numeric = 1,440,000,000 bytes  
 1,440,000,000 / (2^20 bytes / MB) = 1,373.29 MB  
 = 1.34 GB  
 
 This is the RAW data. A bit more is required to read the data: rule of thumb is you require double the memory as the raw data.  

### Other Text Formats  
Not in form of tables. Used to store more metadata, for example class of the data in each column. Work better in version control, as text files are more easily read by git. It can be easier to fix corruption in the file.  
Downside: less space-efficient.  
*dump()* and *dput()* to write, *source()* and *dget()* to read.  

```{r}
y <- data.frame(a = 1, b = "a")
dput(y)

dput(y, file = "y.R")
new.y <- dget("y.R")
new.y
```  

*dput* can only be used on one R object, but *dump* can be used in multiple.  
```{r}
x <- "foo"
y <- data.frame(a = 1, b = "a")
dump(c("x", "y"), file = "data.R")
rm(x, y)   ## removes the objects x and y
source("data.R")   ## reconstructs the objects from the file
y
x
```  

### Interfaces with other things  
Establish connections with files, compressed files or other more exotic things.  
 - *file()*  
 - *gzfile()* file compressed with gzip  
 - *bzfile()* file compressed with bzip2  
 - *url()* opens a connection to a webpage  

*file()* function has the arguments:  
 - *description* name of the file  
 - *open* has a flag to describe:  
  - "r" read only.  
  - "w" writing (and initializing a new file)  
  - "a" appending  
  - "rb", "wb", "ab", as above but in binary mode (windows)  


Connections let you navigate files, too. Often connections happen behind the scenes.  
```{r}
con <- file("datatable.txt", "r")
data <- read.csv(con)
close(con)

 ## these three lines are equivalent to simply using:

data <- read.csv("datatable.txt")
```  

But it can be useful to do so explicitly, such as when reading lines of a text file:  
```{r}
con <- file("datatable.txt")
x <- readLines(con, 10)
x
close(con)
```  
*writeLines()* take a character vector and writes each element one line at a time to a text file.  
*readLines()* can also be used to read from a website, after establishing a connection to a non-file object.
```{r}
con <- url("http://www.jhsph.edu", "r")
x <- readLines(con)
head(x)
close(con)
```   
This is another way to read data other than *read.Table* and *read.csv*.  


## Subsetting
extracting subsets of R objects  
 - "[" always returns an object of the same class as the original. e.g. subsetting a vector makes a vector. Can be used to select more than one element.  
 - "[[" used to extract elements of a list or dataframa. Can only extract a single element. Returned object won't necessarily be of the same class.  
 - "$" is used to extract elements of a list or dataframe by name. Similar to using "[["  
```{r}
x <- c("a", "b", "c", "c", "d", "a")
x[1]
x[2]
x[1:4]  ## subsetting using a numerical index
x[x > "a"]  ## subsetting using a logical index

u <- x > "a"  ## created logical vector u
u
x[u]  ## subsetting using a logical vector as an index
```  
 
### Subsetting Lists  
```{r}
x <- list(foo = 1:4, bar = 0.6, baz = "hello")
x
x[1]  ## extract 1st element, same class as original (a list)
class(x[1])
x[[1]] ## extract 1st element as just a sequence
class(x[[1]])
x$bar ## gives element associated with name "bar"
x[["bar"]] ## same as above
x["bar"] ## same as x[1], returns it as a list

x[c(1,3)]  ## extract multiple elements, returns as same class (list)

name <- "foo" ## the name of an element can be saved as an object, too
x[[name]]  ## useful to look up a name that is automatically computated
x$name  ## doesn't work as [[ ]]. Only looks for the literal name
x$foo  ## works because "foo" is a valid name
```

The [[ can take an integer sequence:  
```{r}
x <- list(a = list(10, 12, 14), b = c(3.14, 2.81))
x[[c(1,3)]]  ## extracts the 3rd element of the 1st list
             ## inception!
x[[1]][[3]]  ## double subsetting, same result as above
x[[c(2,1)]]  ## one more example
```  

### Subsetting Matrices  
Can be subset with a row index and a column index.  
```{r}
x <- matrix(1:6, 2, 3)
x
x[1, 2]
x[2, 1]
```  

Indices can also be missing, which will return a full row or column.  
```{r}
x[1, ]
x[, 2]
```  

By default, when a single element of a matrix is retrieved, it's returned as a vector of length 1, rather than a 1 x 1 matrix. this can be turned off by setting *drop = FALSE*.  
```{r}
x <- matrix(1:6, 2, 3)
x
x[1, 2]
x[1, 2, drop = FALSE]

## A similar behaviour occurs when subsetting a single column 
## or row.

x[1, ]  ## returns a vector
x[1, , drop = FALSE]  ## returns a matrix
```  

### Partial Matching
Partial matching names is allowed with "[[" and "$"  
```{r}
x <- list(aardvark = 1:5, peter = 0.6, paul = 3.14)
x$a  ## by default looks for a name that matches "a". 
x$p  ## fails when there are multiple matches
x[["a"]]  ## looks for an exact match, fails
x[["a", exact = FALSE]]  ## default behaviour can be turned off
```  

### Removing NA values
A common task  
```{r}
x <- c(1, 2, NA, 4, NA, 5)  ## an object that requires cleaning
bad <- is.na(x)  ## logical vector testing for NA
bad
x[!bad]  ## "!" used to invert the logical vector. 
         ## The logical vector determines which elements to return.
```  

You can take the subset of different object that have no missing values:  
```{r}
x <- c(1, 2, NA, 4, NA, 6, 7, 8, NA, 10, 11)
y <- c("a", "b", NA, "d", NA, "f", "g", "h", "i", NA, "k")
good <- complete.cases(x, y)
good
x[good]  ## note some data is lost because of missing values in y
y[good]  ## note some data is lost because of missing values in x
```  

Removing NA values from dataframes. Also removes whole rows or columns where NAs are present.  
```{r}
airquality[1:6, ]  ## example data frame

good <- complete.cases(airquality)  
               ## logical vector tells me which rows are complete.
airquality[good, ][1:6, ]  
        ## subset the airquality matrix using the logical vector
```  

## Vectorised Operations  
Many operations in R are *vectorised*, making code more efficient, concise and easier to read.  
```{r}
x <- 1:4; y <- 6:9
x + y  ## add 1st element of x to 1st element of y, 2nd to 2nd, etc.
x > 2  ## compares all numbers to 2
x >= 2
y == 8  ## == tests for equality
x * y  ## also works with other operations
x / y
```  

Similarly with matrices:  
```{r}
x <- matrix(1:4, 2, 2); y <- matrix(rep(10, 4), 2, 2)
x
y
x * y  ## element-wise multiplication
x / y

x %*% y  ## true matrix multiplication
```

# Week 1 Quiz Questions
```{r}
## Extract the subset of rows of the data frame where Ozone 
## values are above 31 and Temp values are above 90. What is the 
## mean of Solar.R in this subset?

quiz <- read.csv(file = "hw1_data.csv")
Ozone <- quiz[ , 1]  ## creating a list of column 1, Ozone
Temp <- quiz[ , 4]  ## creating a list of column 4, Temp
Solar.R <- quiz[ , 2]  ## creating a list of column 2, Solar.R

Truncated <- cbind(Ozone, Temp, Solar.R)  ## merge into new matrix

Cleanrows <- complete.cases(Truncated)
                 ## logical vector for complete rows

ValidRows124 <- Truncated[Cleanrows, ]  ## extract complete rows

CleanOzone <- ValidRows124[ , 1]  ## List of column 1 of the new matrix
OzoneTest <- CleanOzone > 31  ## logical vector for Ozone column > 31

BigOzone <- ValidRows124[OzoneTest, ]
           ## matrix with rows where ozone is bigger than 31 extracted

CleanTemp <- BigOzone[ , 2]
           ## List of column 2 of the BigOzone matrix
TempTest <- CleanTemp > 90  ## logical vector for Temp column > 90
BigTemp <- BigOzone[TempTest, ] 
        ## matrix with rows where Ozone is bigger than 31 
        ## and Temp is bigger than 90
BigTemp

mean(BigTemp[ , 3])

```  

**A more elegant solution:**
```{r}
## Extract the subset of rows of the data frame where Ozone 
## values are above 31 and Temp values are above 90. What is the 
## mean of Solar.R in this subset?

quiz <- read.csv(file = "hw1_data.csv")  ##reading file
Ozone <- quiz[ , 1]  ## list of column 1, Ozone
Temp <- quiz[ , 4]  ## list of column 4, Temp
Solar.R <- quiz[ , 2]  ## list of column 2, Solar.R

Truncated <- cbind(Ozone, Temp, Solar.R)  ## merge into new matrix

Cleanrows <- complete.cases(Truncated)
                 ## logical vector for complete rows

ValidRows124 <- Truncated[Cleanrows, ]  ## extract complete rows

OandTTest <- ValidRows124[ , 1] > 31 & ValidRows124[ , 2] > 90
        ## execute both tests and save as a logical vector

ValidRows124[OandTTest, ]  ## This is the resulting matrix

mean(ValidRows124[OandTTest, ][ , 3])
      ## taking the mean of the third column of the resulting matrix
```  

**Event Better**
```{r}
## Extract the subset of rows of the data frame where Ozone 
## values are above 31 and Temp values are above 90. What is the 
## mean of Solar.R in this subset?

quiz <- read.csv(file = "hw1_data.csv")  ##reading file
x <- quiz[quiz$Ozone > 31 & quiz$Temp > 90,]
   ## Subset of data frame where row elements labeled "Ozone" 
   ## (column label) are bigger than 31, and rows labeled 
   ## "Temp" (column label) are bigger than 90. 
x[!is.na(x$Ozone), ]
   ## subset of rows, in which th elements labeled "Ozone"
   ## are NOT NAs
mean(x[!is.na(x$Ozone),"Solar.R"]) ## mean of column "Solar.R"
```


```{r}
 ## What is the mean of "Temp" when "Month" is equal to 6? 
quiz <- read.csv(file = "hw1_data.csv")  ##reading file
Temp <- quiz[ , 4]  ## list of column 4, Temp
Month <- quiz[ , 5]  ## list of column 5, Month

Truncated <- cbind(Temp, Month)  ## merge into new matrix
Cleanrows <- complete.cases(Truncated)
                 ## logical vector for complete rows
ValidRows124 <- Truncated[Cleanrows, ]  ## extract complete rows

June <- ValidRows124[ , 2] == 6  ## Logical vector for month = 6
ValidRows124[June, ]  ## the matrix with extracted rows only

mean(ValidRows124[June, ][ , 1]) 
    ## mean of the first column of the matrix with extracted rows only
```  

**Better**
```{r}
 ## What is the mean of "Temp" when "Month" is equal to 6? 
quiz <- read.csv(file = "hw1_data.csv")  ##reading file

quiz[quiz$Month == 6, "Temp"]
  ## Subset elements of column "Temp", on rows where elements 
  ## labeled "Month" are equal to 6.
mean(quiz[quiz$Month == 6, "Temp"])
```



```{r}
## What was the maximum ozone value in the month of May 
## (i.e. Month is equal to 5)?
quiz <- read.csv(file = "hw1_data.csv")  ##reading file
Ozone <- quiz[ , 1]  ## list of column 1, Ozone
Month <- quiz[ , 5]  ## list of column 5, Month

Truncated <- cbind(Ozone, Month)  ## merge into new matrix
Cleanrows <- complete.cases(Truncated)
                 ## logical vector for complete rows
ValidRows124 <- Truncated[Cleanrows, ]  ## extract complete rows

May <- ValidRows124[ , 2] == 5  ## Logical vector for month = 5
ValidRows124[May, ]  ## the matrix with extracted rows only

max(ValidRows124[May, ][ , 1]) 
    ## mean of the first column of the matrix with extracted rows only

```  

**Better**
```{r}
## What was the maximum ozone value in the month of May 
## (i.e. Month is equal to 5)?
quiz <- read.csv(file = "hw1_data.csv")  ##reading file

quiz[quiz$Month == 5, "Ozone"]
  ## extracts the column "Ozone" from the rows where elements 
  ## labeled "Month" are equal to 5
  ## NAs are still present

quiz[quiz$Month == 5 & !is.na(quiz$Ozone), "Ozone"]
  ## add onto that a logical vector to remove NAs

max(quiz[quiz$Month == 5 & !is.na(quiz$Ozone), "Ozone"])
```



# Swirl Exercises Week 1  

## Swirl lesson 1: Basic Building Blocks
New commands:  

 - *ls()* displays a list of all variables saved in the workspace  
 - *getwd()* displays the path t the working directory  
 - *sqrt()* square root  
 - pressing the up arrow on the console shows the previous command  
 - *abs()* absolute value  
 - *c()* can be used to merge vectors or lists, eg:
```{r}
x <- c(2, 23, 1)
c(x, 21, x)
```  

## Swirl lesson 2: Workspace and files
 - *list.files()* displays a character vector with the names of files in the directory.  
 -- *path = * argument to choose directory. Default is *getwd()*  
 -- *?list.files* help page has useful information on arguments.
 -- *file.info()*, *file.access()*, *files()*, *file.choose()* and *choose.files()* could be useful.  
 - *args()* with the function name in the brackets, shows all arguments a function can take, and their default values.  
 - *dir.create("testdir")* to create a new folder.  
 - *setwd("testdir")* sets a new working directory.  
 - *file.create("mytest.R")* creates new file.  
 - *file.exists("mytest.R")* logical vector, tests if file exists.  
 - *file.info("mytest.R")* returns a data frame with details of size, directory, mode, and time stamps.  
 -- *file.info("mytest.R")$mode* retrieves specific items from the data frame  
 - *file.rename("mytest.R","mytest2.R")*  
 - *file.copy("mytest2.R", "mytest3.R")*  
 - *file.path("folder1", mytest3.R")* Character vector that holds a path to a file from components, in a platform-independent way. Example returns *"folder1/mytest3.R"*  
 -- for example *dir.create(file.path("testdir2", "testdir3"), recursive = TRUE)* creates folder "testdir3" inside folder "testdir2".  

## Swirl lesson 3: Sequences of Numbers  
 - *1:20* gives a numerical vector of length 20. Numbers start at 1 and finish at 20, increments of 1.  
 -- *pi:10* also works. value of 10 is not reached.  
 - *seq(1, 10)* does the same, but has more arguments.  
 -- *seq(1, 10, by=0.5)* gives increments of 0.5  
 -- *seq(5, 10, length=30)* calculates even intervals to match the length.  
 -- *seq(along.with = my_seq)* along.with	take the length from the length of this argument.  
 - *length()* gives the length of a vector.  
 - *rep(0, times = 40)* replicates a value to create a vector.  
 -- can also take a vector value. *rep(c(0, 1, 2), times = 10)*  
 -- alternatively, repeat each value with *rep(c(0, 1, 2), each = 10)*  

## Swirl lesson 4: Vectors  
 - logical operators >, <, >=, <=, == and !=  
 - "A | B" means A OR B. "A & B" means A AND B  
 - !A is the negation of A and is TRUE when A is FALSE and vice versa.  
 - *paste(my_char, collapse = " ")* merges the elements of a vector, separating them with a space.  
 - can also be used to join multiple character vectors:  
```{r}
 paste(1:3, c("X", "Y", "Z"), sep = "")
       ## the numeric vector 1:4 gets 'coerced' into 
       ## a character vector by the paste() function.
paste(LETTERS, 1:4, sep = "-")
```  


## Swirl lesson 5: Missing Values  
 - *rnorm(1000)* to create a vector with 1000 draws from a standard normal distribution.  
 - *sample(y, 100)* takes 100 values at random from vector y.  

## Swirl lesson 6: Subsetting Vectors  
 - *x[!is.na(x)]* shorthand to remove NAs  
 - *x[c(3, 20, 21)]* picks the 3rd, 20th and 21st elements of x  
 - *x[-c(3, 20, 21)]* picks all elements of x, except the 3rd, 20th and 21st.  
 - **Named elements in vectors**  
```{r}
c(foo = 11, bar = 2, norf = NA)  ## named from start
vect <- c(11, 2, NA)
names(vect) <- c("foo", "bar", "norf")  ## named after existing
vect
```  
 - *identical (x, y)* gives a logical vector of length 1  
 
## Swirl lesson 7: Matrices and Data Frames  
 - *dim(x)* gives the dimensions of an object. For a vector, that's NULL. Rows, then Columns.  
  - *length(x)* works for vectors.  
 - giving dimensions to a vector will make it into a matrix  
 - *colnames()* can call or set the names of columsn in a data frame  
  - *colnames(my_data) <- c("patient", "age", "weight", "bp", "rating", "test")*  
  
# R Programming Week 2: Programming with R  
 **Learning Objectives**  
 
 - write if-else expressions.  
 - write "for", "while" and "repeat" loops  
 - define a function and specify its return value  
 - describe how R binds a value to a symbol via the search list  
 - explain lexical scoping with respect to how the value of free variables are resolved.  
 - describe the difference between lexical scoping and dynamic scoping rules.  
 - convert character strings representing date & time to an R datetime object.  
 
## Control Structures  
allow you to control the flow of execution of a program. For example:  

 - *if*, *else* tests a condition.  
 - *for* repeat a fixed number of times.  
 - *while* repeat while a condition is true.  
 - *repeat* repeats indefinitely.  
 - *break* stops the execution of a loop.  
 - *next* skips one iterations.  
 - *return* exists a function.  

These are used when writing programs. When writing on the command line, there are a separate set of functions with *apply* which are more useful for loops.
 
### if, else  
The "else" argument is not necessary.
```{r}
x <- rnorm(1, mean = 3)
x
if(x>3) {
        y <- 10
} else {
        y <- 0
}
y
```  
Can also be written as:
```{r}
x <- rnorm(1, mean = 3)
x
y <- if(x>3) {
             10
} else {
             0
}
y
```  

### "For" loops  
*for* loops take an interator variable and assign it successive values from a sequence of a vector. Most commonly used for iterating over the elements of an object.  
```{r}
for(i in 1:10) {
                print(i*2)
}  ## a simple example

x <- c("a", "b", "c", "d", "e")
for (i in 1:4) {
                print(x[i])
  }  ## subsetting x with i to give the first 4 elements of x

for(i in seq_along(x)) {
                        print(x[i])
}  ## seq_along gives all the elements

for(letter in x) {
                  print(letter)
}  ## here "letter" is just an object. Gives all values.

for(i in 1:4) print(x[i]) ## in the same line, the "{" is not needed.
```  

They can also be nested:  
```{r}
x <- matrix(1:6, 2, 3)
x
for(i in seq_len(nrow(x))) {
     ## seq_len creates an integer sequence up to the length of the
     ## object. In this case, the number of rows of x, so the
     ## sequence is 1 2.
          for(j in seq_len(ncol(x))) {
            ## here seq_len will create the sequence 1 2 3, 
            ## as there are 3 columns.
                  print(x[i, j])
            ## as i and j change, here they are the same as the row
            ## and column from the matrix. the subsetting will
            ## extract only one element.
          }
}
```  
Nesting loops beyond 2 or 3 levels can be very difficult to read.

### "While" Loops
The loop begins by testing a condition, and if it's true, runs the code. It then tests the condition again before each iteration.  
```{r}
count <- 0
while(count < 10) {
                  print(count)
                  count <- count + 1
}
```  
Can become infinite if not well written. Be careful.  

There can be more than one condition in the test
```{r}
z <- 5
while(z >= 3 && z <= 10) {
          coin <- rbinom(1, 1, 0.5)  ## set to 1 or 0 randomly
          print(c(z, coin)) ## print value and coin result
          if(coin == 1) {
                    z <- z + 1
          } else {
                    z <- z - 1
          }     ## step up or down at random until a value is reached
                ## that doesn't meet the conditions.
}
```  
Conditions are evaluated left to right.  

### "Repeat" Loops, "Next" and "Break"  
Repeat is not frequently used because it continues to run forever, or until *break* is called within it (typically inside an if function). 
```{r}
x0 <- 10000
tol <- 1

repeat {
        x1 <- sample(-x0:x0, 1)
        print(c("x is ", x1), quote = FALSE)
        if(abs(x1 - x0) <= tol) {
           ## breaks the loop in the two values are within a
           ## tolerance limit set as tol
                break
        } else {
        x0 <- x1
        }
}
```  
It's safer to use a *for* loop with many iterations, then report whether a break was achieved or not.  
```{r}
x0 <- 10000
tol <- 1
conv <- "Convergeance has NOT been achieved"

for(i in 1:10) {
        x1 <- sample(-x0:x0, 1)
        print(c("x is ", x1), quote = FALSE)
        if(abs(x1 - x0) <= tol) {
                print(c(i, "iterations"), quote = FALSE)
                conv <- "Convergeance HAS been achieved"
                break
        } else {
        x0 <- x1
        }
}
print(conv)
```  
This way, if there's a problem with the code, the program will still finish and give you an end. *return* can also finish a loop, but also finishes any functions. Will return to this argument later.  

*Next* can skip one iteration of a loop. E.g.:  
```{r}
for(i in 1:30) {
            if(i <= 10) {
                    next
                    ## skips first 10 iterations
            }
            print(i)
}
```  

## Functions  
Functions are typically held in a separate text file. 
```{r}
source("My_Functions.R")

## a simple function that adds 2 numbers together
add2(286, 365)

## a simple function that gives all elements of a vector that are 
## higher than a threshold. Default threshold is 10.
above(1:20)

## This function gives the mean value of each column in a matrix 
## or data frame. NAs are removed by default, but this can be turned 
## off
columnmean(airquality)
```  

Functions are stored as R objects, with class "function". They are "first class objects", which means they can be treated similarly to other objects. They can be passed as arguments in other functions and they can be nested.  
**The return value of a function is the last expression in its body to be evaluated.**
 
Not all arguments of a function must be included. They may have default values, and they may be called by name or position. E.g.:  
```{r}
mydata <- rnorm(100)
## consider the sd function, that calculates standard deviations.
sd(mydata)
sd(x = mydata)
sd(x = mydata, na.rm = FALSE)
sd(na.rm = FALSE, x = mydata)
sd(na.rm = FALSE, mydata)
   ## in th last example, the order is changed. it might work but
   ## is not recommended.
```  
Positional matching and matching by name can be mixed, which is useful for long list of arguments. E.g.:  
```{r}
mydata <- data.frame(x = 1:50, y = sequence(50, from = 27, by = 2))

args(lm)
y <- 10
x <- 2
  ## the lm() functions has many arguments, some of which 
  ## have defaults
lm(y ~ x, mydata, 1:100, model = FALSE)
lm(data = mydata, y ~ x, model = FALSE, 1:100)
  ## both commands give the same result. But mixing matching is 
  ## not recommended.
```  
Function arguments can also be partially matched for a named argument. When an argument is given, the program will, in order, attempt to match:  
 1. an exact name  
 2. a partial match  
 3. a positional match  
 
In addition, you can also set an argument to *NULL*. It can mean a variety of things.  
```{r}
source("My_Functions.R")
args(above)
above(1:20, n = NULL)
```  

The arguments to a function are only evaluated as they are needed.  
```{r, error = TRUE }
f <- function(a, b) {
        a^2
}
f(2)  
        ## even though argument b is undefined and has no default, 
        ## it still gives a logical value, because argument b is 
        ## not used.

f <- function(a, b) {
        print(a)
        print(b)
}
f(2)  
        ## error only occurs when b is needed. the function 
        ## works correctly up to then.
```  

### The "..." Argument  
Indicates a variable number of arguments which are usually passed onto another function. Often used to extend another function, without copying the entire list of arguments from that function.  
```{r}
myplot <- function(x, y, type = "l", ...) {
            plot(x, y, type = type, ...)
}  ## imitates plot functions, but sets type to "l" by default.
```  
Generic functions use ... so that extra arguments can be passed to methods (more on this later).

It is also necessary when the number of arguments cannot be known in advance.  
```{r}
args(paste)
x <- "Hello"
y <- "world!"
z <- "I'm"
w <- "R!"
paste(x, y, z, w, sep = " ", collapse = NULL, recycle0 = FALSE)
      ## several arguments can be placed in the ... position.

args(cat)  ## similar function
```
You **CANNOT** use positional matching nor partial matching for arguments that come after the "..."  

## Scoping Rules  
### Symbol Binding
What happens if you assign a function string that already exists?  
```{r}
lm <- function(x) x * x
lm(5)
```  
the *lm()* function already exists and is defined in the stats package. But R will first search for the meaning of lm in the *global environment* (the workspace and objects set by the user). After that it works through a list of other environments in order, until it find it. The list can be viewed with the *search()* function.  
```{r}
search()
```  
Order matters! Can be configured by the user. When loading a package with the *library()* function, that package gets put to position 2 in the list, after the global environment, and everything else is pushed down one level.  
Note that R has separate namespaces for functions and non-functions. So it is possible to have an object named *c* and a function named *c*. (Though on the global environment there can only be one object named *c*)

### R Scoping Rules
 - Determine how a value is associated with a free variable in a function  
 - *lexical* aka *static* scoping. (an alternative is *dynamic* scoping)  
 - R uses the *search* list to bind a value to a symbol  
 - *lexical scoping* is particularly useful for sumplifying statistical computations.  
```{r}
f <- function(x, y) {
            x^2 + y / z
}
```  
How does R assign a value to *z*, if it's not defined in the function header?  

 - *the values of free variables are searched for in the environment in which the function was defined.*  
 -- An environment is a collection of (symbol, value) pairs  
 -- every environment has a parent environment, and can have multiple children environments.  
 -- the only environment without a parent is the empty environment  
 -- a function + an environment = a closure (or function closure)  
 - First R searches for the free variable in the environment of the function. It then continues searching in the parent environment.  
 - the search continues down the sequence until it reaches the top-level environment.  
 - after that, it continues down the *search* list until it hits the empty environment. If no value is found, an error is shown.  
```{r}
make.power <- function(n) {
                pow <- function(x) {
                          x^n
                }
                pow
}  ## this function returns another function as its value. 
   ## so i can use:
cube <- make.power(3)
square <- make.power(2)
   ## to make functions "cube" and "square" that call "pow" 
   ## with a value
cube(5)
square(5)
```  
 - *ls(environment())* can be used to call the environment of a function. (*ls()* lists objects.)  
 - *get()* returns the value of an object, and can be used to find the value of arguments of a function, e.g.:  
```{r}
ls(environment(cube))
get("n", environment((cube)))

ls(environment(square))
get("n", environment((square)))
```  

**What does this mean?**
```{r}
y <- 10
f <- function(x) {
          y <- 2
          y^2 + g(x)
}

g <- function(x) {
          y * x
}
f(3)  
        ## results in 34 because y is set to 2 in the function f, 
        ## but not in the function g
g(3)  
        ## results in 30 because the environment of g doesn't 
        ## include setting y to 2.
```  
 - in *lexical* scoping the value of y is looked up in the environment where the function is defined.  
 - in *dynamic* scoping the value of y is looked up in the environment where the function is **called** (known as "calling environment")  
 -- in R this is called the "parent frame"  

**Consequences of Lexical Scoping**  

 - In R all objects must be stored in memory.  
 - functions must carry a pointer to their respective environments, which could be anywhere.  
 - In S-PLUS, for comparison, free variables are always looked up in the global workspace. So everything can be stored in the disk, because the "defining environment" of all functions was the same.  
 
## Coding Standards  
 Making code readable.  
 
 - write your code using a text editor and save it as a text file.  
 -- these can be read by any editing program.  
 - indent your code. (8 spaces per tab?)  
 - limit the width of your code.(80 columns?).  
 -- forces you to limit nesting loops, which is not very readable.  
 - limit the length of individual functions: one basic activity.  
 -- helps you debug functions and which function is malfunctioning.  
 
## Dates and Times in R  
Represented using special object classes:  

 - Dates are represented by the *Date* class  
 -- Dates are stored internally as the number of days since 1970-01-01  
 - Times are represented by the *POSIXct* or the *POSIXlt* class  
 -- Times are stored internally as the number of seconds since 1970-01-01  
 -- *POSIXct* is stored internally as a large integer, and is useful for storing times in something like a data frame  
 -- *POSIXlt* is stored internally as a list, and includes other information such as day of the week, day of the year, day of the month.  
 -- Functions that work on dates and times:  
 --- *weekdays*  
 --- *months*  
 --- *quarters*  
```{r,  error = TRUE }
x <- as.Date("1970-01-01")
x
unclass(x)
unclass(as.Date("1970-01-02"))
unclass(as.Date("1969-12-31"))

y <- Sys.time()
y

p <- as.POSIXlt(y)
names(unclass(p))

p$sec
p$yday

y  ## Sys.time() is already in POSIXct format
unclass(x)
x$sec  ## returns error since it is stored as only an integer
```  
The *strptime* function helps convert dates and times written in different formats.  
```{r}
datestring <- c("January 10, 2020 16:45", "September 26, 1986 03:21")
x <- strptime(datestring, "%B %d, %Y %H:%M")
x
class(x)
## use the help page to remember what the strings are
```  
You can use data and time objects to perform calculations, comparisons, etc. But they must be the same class. The operators keep track of tricky things like leap years and time-zones. Plotting functions also recognise date & time objects and interpret them in unique ways.  

# Week 2 Quiz Questions  
```{r}
f <- function(x) {
        g <- function(y) {
                y + z
        }
        z <- 4
        x + g(x)
}
z <- 10
f(3)
```

# Week 2 Programming Assignment  
## Part 1  
```{r}
## Write a function named 'pollutantmean' that calculates the mean of a 
## pollutant (sulfate or nitrate) across a specified list of monitors. The 
## function 'pollutantmean' takes three arguments: 'directory', 'pollutant',
## and 'id'. Given a vector monitor ID numbers, 'pollutantmean' reads that 
## monitors' particulate matter data from the directory specified in the 
## 'directory' argument and returns the mean of the pollutant across all of
## the monitors, ignoring any missing values coded as NA. A prototype of
## the function is as follows
 
##  pollutantmean <- function(directory, pollutant, id = 1:332) {
                ## 'directory' is a character vector of length 1 indicating
                ## the location of the CSV file.
                
                ## 'pollutant' is a character value of length 1 indicating
                ## the name of the pollutant for which we will calculate the
                ## mean; either "sulfate" or "nitrate". 
                
                ## 'id' is an integer vector indicating the monitor ID
                ## numbers to be used
                
                ## Return the mean of the pollutant across all monitors list
                ## in the 'id' vector (ignoring NA values_
                ## NOTE: Do not round the result)
##  }

## You can see some example output from this function below. The function
## that you write should be able to match this output. Please save your code
## to a file named pollutantmean.R.

## https://d3c33hcgiwev3.cloudfront.net/_3b0da118473bfa0845efddcbe29cc336_pollutantmean-demo.html?Expires=1600473600&Signature=kmxefxIfSh~d58GQH7-acWeSAjn1d6oVB-aKqk8ZuY~2XXuWT1H9ERs2c-u6eS-osJNDcDHqdph4uEvS3cZnMMpfnrI3EgoTnKvkCzs4xbOtWugaKsuwZALETKeUleeE3Zmnbz9yiB96hZfBSVyZSwC1NoAELGVuDt0kuJ7ReS4_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

source("pollutantmean.R")
a <- pollutantmean("specdata", "sulphate", 1:10)
b <- pollutantmean("specdata", "nitrate", 70:72)
c <- pollutantmean("specdata", "nitrate", 23)
c(a, b, c)
```  

## Part 2  
```{r}
## Write a function that reads a directory full of files and reports the
## number of completely observed cases in each data file. The function
## should return a data frame where the first column is the name of the
## file and the second column is the number of complete cases. A
## prototype of this function follows:

## complete <- function(directory, id = 1:322) {
        ## 'directory' is a character vector of length 1 indicating
        ## the location of the CSV files
         
        ## 'id' is an integer vector indicating the monitor ID numbers
        ## to be used
         
        ## Return a data frame of the form:
        ## id nobs
        ## 1 117
        ## 2 1041
        ## ...
        ## where 'id' is the monitor ID number and 'nobs' is the
        ## number of complete cases.
## }

## You can see some example output from this function below. The function
## that you write should be able to match this output. Please save your 
## code to a file named complete.R. To run the submit script for this part,
## make sure your working directory has the file complete.R in it.
## 
## https://d3c33hcgiwev3.cloudfront.net/_3b0da118473bfa0845efddcbe29cc336_complete-demo.html?Expires=1600992000&Signature=gF2NcTe77KzJFYL8nvEfhNJkJ5bsSS505uqCoL81tOOjBesuP1y-8ukQr1IwTArMjicmnA82chASNa-3eDHF~wyfs0yTa0Z2se6uawggD5~LDYVAJw-PcDlNfv~m3i4Ab3smdONOByevfvMYNMO8WGQ8SSv2l8fIbtPZayErCbI_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A

source("complete.R")
complete("specdata", 1)
complete("specdata", c(2, 4, 8, 10, 12))
complete("specdata", 30:25)
complete("specdata", 3)
```  


## Part 3  
```{r}
## Write a function that takes a directory of data files and a threshold for
## complete cases and calculates the correlation between sulfate and
## nitrate for monitor locations where the number of completely observed
## cases (on all variables) is greater than the threshold. The function
## should return a vector of correlations for the monitors that meet the
## threshold requirement. If no monitors meet the threshold requirement,
## then the function should return a numeric vector of length 0. A prototype
## of this function follows

## corr <- function(directory, threshold = 0) {
## 'directory' is a character vector of length 1 indicating the location of
## the CSV files

## 'threshold' is a numeric vector of length 1 indicating the number of 
## completely observed observations (on all variables) required to compute
## the correlation between nitrate and sulfate; the default is 0

## return a numeric vector of correlations
## NOTE: Do not round the result!
## }

## For this function you will need to use the 'cor' function in R which
## calculates the correlation between two vectors. Please read the help 
## page for this function via '?cor' and make sure that you know how to 
## use it.

## You can see some example output from this function below. The function
## that you write should be able to approximately match this output. Note
## that because of how R rounds and presents floating point numbers, the
## output you generate may differ slightly from the example output. Please
## save your code to a file named corr.R. To run the submit script for this
## part, make sure your working directory has the file corr.R in it.

## https://d3c33hcgiwev3.cloudfront.net/_e92e575b8e62dcb1e3a086d2ff0d5a1e_corr-demo.html?Expires=1600992000&Signature=GmWEdZ-a~LTbW42FuTGEivk5yK5lHU1dL-W4feLDoYsxdhxJGQggsEsI1CghJfbDozGCmubCMgFJXyMpPD1YD8gl2ize7WZVH9X8MhsLE~2p4mGt7xS4KL88MtroisgJnZlg51TZxysolTJlKSTNZlB8sthzm5du2A9Zy7ugKYc_&Key-Pair-Id=APKAJLTNE6QMUY6HBC5A 

source("corr.R")
source("complete.R")
cr <- corr("specdata", 150)
head(cr)
summary(cr)
cr <- corr("specdata", 400)
head(cr)
summary(cr)
cr <- corr("specdata", 5000)
summary(cr)
length(cr)
cr <- corr("specdata")
summary(cr)
length(cr)
```  

# Swirl Exercises Week 2  
## Swirl Lesson 8: Logic  
 - Logical operators *==*, *!=*, *>*, *>=*, *<*, *<=*  
 -- *%%* is used to find the remainder.
 - *"!"* in front of a *TRUE* returns a *FALSE* and vice-versa  
```{r}
15 %% 7
TRUE == TRUE
(FALSE == TRUE) == FALSE
5 != 7
! 5 == 7
!(0 >= -1)
(TRUE != FALSE) == !(6 == 7)
```  
 - *"&"* and *"&&"* return TRUE only if both parts are TRUE  
 -- *"&"* evaluates each element in a vector (recycling may happen).  
 -- *"&&"* evaluates only the first element of vectors.  
 - *"|"* and *"||"* return TRUE if either parts are TRUE  
 -- same differences as for *"&"* and *"&&"*  
 - All **AND** operators are evaluated before **OR** operators.  
```{r}
TRUE & TRUE
FALSE & TRUE
FALSE & FALSE
TRUE & c(TRUE, FALSE, FALSE)
TRUE && c(TRUE, FALSE, FALSE)
6 != 10 && FALSE && 1 >= 2
5 > 8 || 6 != 8 && 4 > 3.9
```  
 - *isTRUE()* returns TRUE only if the argument inside is *TRUE*, otherwise it returns *FALSE*.  
 - *identical()* returns TRUE is both arguments are identical.  
 - *xor()* is the exclusive **OR**. It returns TRUE if only one element is TRUE.  
 - *which()* takes a logical vector as argument and returns the indeces of TRUE elements.  
 - *any()* and *all()* return TRUE if any or all elements of a logical vector are TRUE, respectively.  
```{r}
isTRUE("egg salad")
isTRUE(5 != 4)
identical("hello", "Hello")
xor(5 == 6, !FALSE)
xor(5 <= 6, 4*3 == 12)
which(c(TRUE, FALSE, TRUE))
any(c(1, 2, 3, 4, 5, 6) < 0)
all(c(1, 2, 3, 4, 5, 6) > 0)

```  
 
## Swirl Lesson 9: Functions  
### Functions as arguments  
You can pass functions as arguments to other functions just like you can pass data to functions. Let's say you define the following functions:  
```{r}
add_two_numbers <- function(num1, num2){
    num1 + num2
}

multiply_two_numbers <- function(num1, num2){
  num1 * num2
}

some_function <- function(func){
    func(2, 4)
}

some_function(add_two_numbers)
some_function(multiply_two_numbers)
some_function(paste)
```
As you can see we use the argument name "func" like a function inside of "some_function()."  
 
Finish the function definition below so that if a function is passed into the "func" argument and some data (like a vector) is passed into the dat argument the evaluate() function will return the result of dat being passed as an argument to func.  
```{r}
evaluate <- function(func, dat){
  func(dat)
}

evaluate(sum, c(2, 4, 6))
evaluate(median, c(7, 40, 9))
evaluate(floor, 11.1)
```  

### Ellipses as arguments
The ellipses can be used to pass on arguments to other functions that are used within the function you're writing. Usually a function that has the ellipses as an argument has the ellipses as the last argument. The usage of such a function would look like: *ellipses_func(arg1, arg2 = TRUE, ...)*  
In the above example arg1 has no default value, so a value must be provided for arg1. arg2 has a default value, and other arguments can come after arg2 depending on how they're defined in the ellipses_func() documentation. Interestingly the usage for the paste function is as follows:  
*paste (..., sep = " ", collapse = NULL)*  
Notice that the ellipses is the first argument, and all other arguments after the ellipses have default values. This is a strict rule in R programming: all arguments after an ellipses must have default values. Take a look at the simon_says function below:  
```{r}
simon_says <- function(...){
   paste("Simon says:", ...)
}
simon_says("put your hands on your head!")
```  

Telegrams used to be peppered with the words START and STOP in order to demarcate the beginning and end of sentences. Write a function below called  telegram that formats sentences for telegrams. For example the expression `telegram("Good", "morning")` should evaluate to:
*"START Good morning STOP"*  
```{r}
telegram <- function(...){
  paste("START", ..., "STOP")
}
telegram("Good", "morning")
```  

### Unpacking Elipses  
Let's explore how to "unpack" arguments from an ellipses when you use the ellipses as an argument in a function. Below I have an example function that is supposed to add two explicitly named arguments called alpha and beta.
```{r}
add_alpha_and_beta <- function(...){
   # First we must capture the ellipsis inside of a list
   # and then assign the list to a variable. Let's name this
   # variable `args`.

   args <- list(...)

   # We're now going to assume that there are two named arguments within args
   # with the names `alpha` and `beta.` We can extract named arguments from
   # the args list by using the name of the argument and double brackets. The
   # `args` variable is just a regular list after all!
   
   alpha <- args[["alpha"]]
   beta  <- args[["beta"]]

   # Then we return the sum of alpha and beta.

   alpha + beta 
}

add_alpha_and_beta(alpha = 100, beta = 20)
```  

Have you ever played Mad Libs before? The function below will construct a sentence from parts of speech that you provide as arguments. We'll write most of the function, but you'll need to unpack the appropriate arguments from the ellipses.
```{r}
mad_libs <- function(...){
  # Do your argument unpacking here!
  
  args <- list(...)
  place <- args["place"]
  adjective <- args["adjective"]
  noun <- args["noun"]
  
  # Don't modify any code below this comment.
  # Notice the variables you'll need to create in order for the code below to
  # be functional!
  paste("News from", place, "today where", adjective, "students took to the streets in protest of the new", noun, "being installed on campus.")
}
mad_libs(place = "Christchurch", adjective = "uncool", noun = "Ski ramp")
```  

### Creating Binary Operators  
The syntax for creating new binary operators in R is unlike anything else in R, but it allows you to define a new syntax for your function. I would only recommend making your own binary operator if you plan on using it often!  
User-defined binary operators have the following syntax:  
*%[whatever]%*  
where [whatever] represents any valid variable name.  
Let's say I wanted to define a binary operator that multiplied two numbers and then added one to the product. An implementation of that operator is below:  
```{r}
"%mult_add_one%" <- function(left, right){ # Notice the quotation marks!
   left * right + 1
}
4 %mult_add_one% 5
```  
  
Write your own binary operator below from absolute scratch! Your binary operator must be called %p% so that the expression:  
"Good" %p% "job!"  
will evaluate to: "Good job!"  
```{r}
"%p%" <- function(left, right){ 
  paste(left, right)
}
"Hello" %p% "world!"
```  

## Swirl Lesson 14: Dates and Times  
 - *Sys.Date()* gets a date object with the current date  
 - *as.Date("1986-09-26")* to create a custom date object  
 -- use *unclass(Sys.Date())* to see that dates are stored as days since 1970-01-01.  
 -- dates before 1970 are stored as negative numbers.  
 - *Sys.time()* is a POSIXct object with the current time.  
 -- time is stored internally as the number of seconds since 1970-01-01 00:00:00  
 - *as.POSIXlt(Sys.time())* coerces it into a POSIXlt object  
 -- it is stored internally as a list, with elements representing seconds, minutes, hours, day of month, month, year, day of week, day of year, daylight savings, time zone, and two more time zone related elements.  
```{r}
t1 <- as.POSIXlt("1986-09-26 12:45:00 BRT")
str(unclass(t1))  ## str() Compactly displays structure of an object.
t1$min  ## easily extracted elements
```  
 - *weekdays()* returns day of the week for any date or time object.  
 - *months()* returns the month.  
 - *quarters()* returns the quarter of th year.  
 -- there functions work on date, POSIXct and POSIXlt objects.  
```{r}
t1 <- as.POSIXlt("1986-09-26 12:45:00 BRT")
weekdays(t1)
months(t1)
quarters(t1)
```  
 - *strptime()* can extract dates and times from formats not recognised by R.  
 -- it converts a character vector into POSIXlt.  
```{r}
t1 <- "October 17, 1986 08:24"
strptime(t1, "%B %d, %Y %H:%M")
```  
 - arithmetic operations + and -, and comparisons <, > and == can be performed on date and time objects.  
 - *difftime()* allows for more precise control of units when performing subtractions.  

# R Programming Week 3:  Loop Functions and Debugging  
Writing *for* and *while* loops in the command line is cumbersome. The loop functions that contain the word *"apply"* are more convenient. We'll look into several variants.  

**Learning Objectives**  
 - Use the loop functions *apply*, *lapply*, *tapply*, *mapply* and *split*.  
 - Define an anonymous function and describe its use in loop functions.  
 - Describe how to start the R debugger for an arbitrary R function.  
 - Describe what the traceback() function does and what is the function call stack.  
 
## Loop Functions - *lapply*  
Loop over a list of objects and apply a function to every element. *sapply* does the same and tries to simplify the results.  
```{r}
lapply
```  
 - *"X"* must be a list or it will be coerced into a list.  
 - *"FUN"* is a function to apply and "..." are arguments of that function.  
 - the actual looping is done internally through C code, to make it faster.  
 - always returns a list. Names are preserved.  
```{r}
## Example
x <- list(a = 1:5, b = rnorm(10), c = rnorm(5, 10))
lapply(x, mean)

## runif() function generates "n" random numbers between 0 and 1
lapply(1:4, runif)

## optional arguments of runif() can be passed into the "..." argument
lapply(1:4, runif, min = 0, max = 10)
```  

### Using loop functions with anonymous functions  
Anonymous functions can be very useful in combination with *apply* loops.  
```{r}
## Consider a list of matrices
x <- list(a = matrix(1:4, 2, 2), b = matrix(1:6, 3, 2))
x

## we can create an anonymous function to extract the first column of each 
## matrix
lapply(x, function(arg) arg[ ,1])
```

### *sapply* will try to simplify the result of lapply  
 - If the result is a list where every element is length 1, then a vector is returned.  
 - If the result is a list where every element is a vector with the same length, a matrix is returned.  
 - If sapply can't simplify the output, a list is returned.  
```{r}
x <- list(a = 1:5, b = rnorm(10), c = rnorm(5, 10))
sapply(x, mean)  ##returns a vector instead of a list

mean(x) ## doesn't work because mean doesn't apply to lists. 

x <- list(a = 1:5, b = rnorm(10), c = rnorm(5, 10), d = c("a", "b", "c"))
y <- sapply(x, mean)  ## calculates means where possible and returns NA
y                     ## otherwise

class(y)
```  

## Loop functions - *apply*  
Used to evaluate a function over the margins of an array (matrices or 3d arrays). It used to be faster than using a a for loop, but that's no longer the case. It just requires less typing.  
```{r}
args(apply)
```  
 - *"X"* is an array (e.g. a matrix).  
 - *"MARGIN"* is an integer vector indicating which margins should be retained.  
 - *"FUN"* is a function.  
 - *"..."* is for arguments to be passed to the function.  
```{r}
x <- matrix(rnorm(200), 20, 10)  ## an example matrix

## Calculate the mean of each column
## dimension 1 has 20 rows and dimension 2 has 10 columns.
apply(x, 2, mean) ## preserve columns, collapse rows

## Calculate the sum of each row
apply(x, 1, sum) ## preserve rows, collapse columns.
```  
For sums and means of matrix dimensions, however, there are faster, optimized functions:  
 - *rowSums()* = apply(x, 1, sum)  
 - *rowMeans()* = apply(x, 1, mean)  
 - *colSums()* = apply(x, 2, sum)  
 - *colMeans()* = apply(x, 2, mean)  

For functions that return a vector of length > 1, *apply()* can create a matrix.  
```{r}
## Another example
## signif() is used to round to significant figures.
x <- matrix(signif(rnorm(50, 10, 5),3), 5, 10)
x
## the quantile() function calculates percentiles in a population.
apply(x, 1, quantile, probs = c(0, 0.5, 1))
```
Each row of the matrix is analysed by the quantile function, which gives a vector of length 3. So *apply()* builds a matrix with the rows of "x" as the column names and the quantiles that the *quantile()* function calculates as the rows.

Using *apply()* in an array:  
```{r}
## a is an array of dimensions 2 by 2 by 10
a <- array(signif(rnorm(2 * 2 * 10), 2), c(2, 2, 10))

## preserve dimensions 1 and 2, operate the function of the 3rd dimension.
apply(a, c(1, 2), mean)

## can also be achieved by:
rowMeans(a, dims = 2)
```

## Loop functions - *mapply*  
is a multivariate apply. It can apply a function in parallel over a set of arguments. It can have multiple lists as arguments.
```{r}
args(mapply)
```  
 - *"FUN"* is a function  
 - *"..."* contains arguments to apply to the function. (coerced to list)  
 - *"MoreArgs"* is a list of other arguments to FUN.  
 - *"SIMPLIFY"* indicates whether the result should be simplified.  
```{r}
list(rep(1, 4), rep(2, 3), rep(3, 2), rep(4, 1))

## instead, we can have mapply use the rep() function
mapply(rep, 1:4, 4:1)

noise <- function(n, mean = 5, sd = 2) {
        signif(rnorm(n, mean, sd), 2)
}

## If I wanted to create sets of 6 to 10 random numbers with noise(), each
## set having average 2, 4, 6, 8 and 10 respectively. 
## noise(6:10, c(2, 4, 6, 8, 10), 2) won't work because the arguments must be single elements.
## Using mapply, we can do this:
mapply(noise, n = 6:10, mean = c(2, 4, 6, 8, 10), sd = 2)
```
Use a function that doesn't allow vector inputs and vectorise it.

## Loop Functions - *tapply*  
used to apply a function over subsets of a vector.  
```{r}
args(tapply)
```  
 - *"X"* is a vector.  
 - *"Index"* is a vector of same length or a list of factors (coerced into list).  
 - *"FUN"* is a function.  
 - *"..."* contains other arguments of *FUN*.  
 - *"simplify"* to simplify the result.  
```{r}
x <- c(rnorm(10), runif(10), rnorm(10,1)) ## runif is random of uniform dist.
f <- gl(3, 10)  ## generates a numeric vector, elements are 1 repeated k times,
                ## then 2 repeated k times, then 3, until the number is equal 
                ## to n. 
f
tapply(x, f, mean)
```  
 - the factor variable determines which elements of the vector will be grouped together.  
```{r}
tapply(x, f, range)
```  
 - Here a minimum and a maximum are given for each group, so the result of *tapply* is a list where each element is a vector of length 2. 

## Loop Functions - *split*  
Works very similarly to *tapply*, but it doesn't apply a function to the elements.  
```{r}
args(split)
```  
 - useful for using before *lapply* or *mapply*  
 - can be used to split much more complicated objects.  
 - always results in a list.  
```{r}
x <- c(rnorm(10), runif(10), rnorm(10,1))
f <- gl(3, 10)
split(x, f)

lapply(split(x, f), mean)  ## exactly same thing as the tapply function
```  

```{r}
library(datasets)
head(airquality)

## For example if I wanted to calculate the mean of Ozone, solar radiation,
## wind and temperature within each month. I can split the data frame into 
## monthly pieces.
s <- split(airquality, airquality$Month)
lapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")])) 
## includes NAs
```  

I can then also use *sapply* to give the results a a matrix instead:  
```{r}
sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")]))

## and I can remove NAs with the 'na.rm' argument of colMeans

sapply(s, function(x) colMeans(x[, c("Ozone", "Solar.R", "Wind")], na.rm = TRUE))
```  

### Splitting on more than one level  
Using two different factors for splitting.  
```{r}
x <- rnorm(10)
f1 <- gl(2, 5)
f2 <- gl(5, 2)

## For example if I have a population of measurement and they are tagged 
## by both gender and age group.
cbind(x, f1, f2)

interaction(f1, f2)  ## Combines the levels of both factors. There's now 10.

str(split(x, list(f1, f2))) 
## the split function doesn't require the use of the interaction function. 
## Not all levels have observations, they result in an empty vector. 

str(split(x, list(f1, f2), drop = TRUE))  ## drops empty levels from the result
## very useful for later using an sapply or lapply.
```  

## Debugging Tools - Diagnosing the Problem  
Indication R will give that something's wrong:  

 - **message**: an expected notification/diagnostic produced by the *message* function; execution of the function continues. Message appears in the middle.  
 - **warning**: an indication of something wrong, but not fatal. execution of the function continues. generated by the *warning* function. Message appears after the function.  
 - **error**: a fatal problem has occurred. execution stops. produced by the *stop* function.  
 - **condition**: a generic concept for indicating that something unexpected can occur. programmer can create their own conditions.  
```{r, error = TRUE}
log(-1)  ## Basic warning. 
```  
```{r, error = TRUE}
printmessage <- function(x) {
        if(x > 0)
                print("x is greater than zero")
        else
                print("x is less than of equal to zero")
        invisible(x)  ## prevents auto-printing
}
printmessage(1)

printmessage(NA)  ## error produced!
```  
```{r, error = TRUE}
printmessage2 <- function(x) {
        if(is.na(x))
                print("x is a missing value!")
        else if(x > 0)
                print("x is greater than zero")
        else
                print("x is less than of equal to zero")
        invisible(x)
}
x <- log(-1)

printmessage2(x) ## no error produced, but unexpected.
```  
How do you know that something is wrong with your function?  

 - What was your input? How did you call the function? Arguments, etc?  
 - What were you expecting? Output, messages, other results?  
 - What did you get?  
 - How does it differ from what you were expecting?  
 - Were your expectations correct in the first place?  
 - Can you reproduce the problem?  

## Debugging Tools - Basic Tools  
The primary tools for debugging functions in R:  

 - *traceback*: prints out the function call stack after an error occurs: does nothing if there is no error.  
 - *debug*: flags a function for "debug mode". when the function is next called, it will freeze and you can step through the function line-by-line.  
 - *browser*: similar to *debug*. when read, execution will suspend and you can go line-by-line. Can stop the function in the middle, instead of the start.  
 - *trace*: allows you to insert debugging code into a function without changing the function.  
 - *recover*: allows you to modify the default error behaviour, so you can browse the function call stack.  

## Debugging Tools - Using the Tools (examples)  
### Traceback
```{r, error = TRUE}
mean(xxx)

## traceback()  ## has to be called immediately after error occurs
```  
```{r, error = TRUE}
lm(xxx - yyy)
## traceback()  ## error actually occurred 4 levels deep. 
```  
Useful for giving details of errors to others, when asking for help.  

### Debug
*debug* is hard to see in static form, but here's an example:  
```{r, error = TRUE}
# debug(lm)  ## prints out the full body of the next function, 
           ## then opens the browser.
lm(xxx - yyy)
```  
The browser acts just like a separate workspace. The environment of this workspace is the environment of the function. Type *n* and enter to run the next line. You can then use debug on a function inside that function to browse that function. 

### Recover
```{r, error = TRUE}
# options(error = recover)
  ## Sets a global option for this R session. 

read.csv("nosuchfile")
```  
Instead of getting the console back, you get a menu. This is similar to the output of the traceback function. Error occurred at 3rd level, so you can type 3 to browse the environment of that function.  

# Swirl Exercises Week 3  
## Swirl Lesson 10: lapply and sapply  
These functions offer a concise and convenient means of implementing the **Split-Apply-Combine strategy** for data analysis. That means, the function will *split* up the data into smaller pieces, *apply* a function to each piece, then *combine* the results.  

Consider a data frame with several columns representing measured variables and rows representing observations (for example countries where the measurements were taken). Suppose we want to know the class of object of each column. We could individually look it up with a subsetting function, but since we need to do this for many columns, we can use *lapply* to do it as a loop for all of them. *lapply(dataframe, class)* command will give a list of all the column names and the class of the object. *sapply* does the same, but, if possible, simplifies the result into a vector or matrix instead of a list.  

## Swirl Lesson 11: vapply and tapply  
*vapply* works similarly to *sapply*, however you specify the object class you want as an output. If the function cannot convert the object into that class, it throws an error. This can prevent significant problems in code, that might be caused by getting an unexpected return value from *sapply*.  
```{r, error = TRUE}
x <- data.frame(name = c("a", "b", "c", "d", "e"), min = runif(5, 0, 10), max = runif(5, 10, 200), tree = c(TRUE, FALSE, FALSE, FALSE, FALSE), num = 1:5)
x
sapply(x, class)
vapply(x, class, character(1))
vapply(x, class, numeric(1))  ## error produced because output is not numeric
```  

*tapply* splits the data up into groups, based on the value of a variable vector, then applies a function to each group.  
```{r}
x <- data.frame(fus = runif(30), roh = runif(30), dah = runif(30), dborn = gl(5, 6))
x
tapply(x$fus, x$dborn, mean) 
  ## takes the mean of column "fus", but separated into the groups set 
  ## by "dborn"
```  

# Quiz Week 3
Take a look at the 'iris' dataset that comes with R. The data can be loaded with the code:
```{r}
library(datasets)
data(iris)
data(mtcars)
```  
Q: There will be an object called 'iris' in your workspace. In this dataset, what is the mean of 'Sepal.Length' for the species virginica? Please round your answer to the nearest whole number.  
A: 7  

Q: Continuing with the 'iris' dataset from the previous Question, what R code returns a vector of the means of the variables 'Sepal.Length', 'Sepal.Width', 'Petal.Length', and 'Petal.Width'?  
A: apply(iris[, 1:4], 2, mean)  

Q: Load the 'mtcars' dataset in R with the following code. There will be an object names 'mtcars' in your workspace. How can one calculate the average miles per gallon (mpg) by number of cylinders in the car (cyl)? Select all that apply.  
A: 
```{r}
sapply(split(mtcars$mpg, mtcars$cyl), mean)
tapply(mtcars$mpg, mtcars$cyl, mean)
```  

Q: Continuing with the 'mtcars' dataset from the previous Question, what is the absolute difference between the average horsepower of 4-cylinder cars and the average horsepower of 8-cylinder cars? (Please round your final answer to the nearest whole number.  
A: 127  

Q: If you run *debug(ls)* what happens when you next call the 'ls' function?  
A: Execution of 'ls' will suspend at the beginning of the function and you will be in the browser.  

# Week 3 Assignment  
Matrix inversion is usually a costly computation and there may be some benefit to caching the inverse of a matrix rather than compute it repeatedly (there are also alternatives to matrix inversion that we will not discuss here). Your assignment is to write a pair of functions that cache the inverse of a matrix.  

Write the following functions:  

 * makeCacheMatrix: This function creates a special "matrix" object that can cache its inverse.  
 * cacheSolve: This function computes the inverse of the special "matrix" returned by makeCacheMatrix above. If the inverse has already been calculated (and the matrix has not changed), then the cachesolve should retrieve the inverse from the cache.  

Computing the inverse of a square matrix can be done with the solve function in R. For example, if X is a square invertible matrix, then solve(X) returns its inverse.  

For this assignment, assume that the matrix supplied is always invertible.  

In order to complete this assignment, you must do the following:  

 - Fork the GitHub repository containing the stub R files at https://github.com/rdpeng/ProgrammingAssignment2 to create a copy under your own account.  
    Clone your forked GitHub repository to your computer so that you can edit the files locally on your own machine.
    Edit the R file contained in the git repository and place your solution in that file (please do not rename the file).
    Commit your completed R file into YOUR git repository and push your git branch to the GitHub repository under your account.
    Submit to Coursera the URL to your GitHub repository that contains the completed R code for the assignment.

In addition to submitting the URL for your GitHub repository, you will need to submit the 40 character SHA-1 hash (as string of numbers from 0-9 and letters from a-f) that identifies the repository commit that contains the version of the files you want to submit. You can do this in GitHub by doing the following

    Going to your GitHub repository web page for this assignment
    Click on the “?? commits” link where ?? is the number of commits you have in the repository. For example, if you made a total of 10 commits to this repository, the link should say “10 commits”.
    You will see a list of commits that you have made to this repository. The most recent commit is at the very top. If this represents the version of the files you want to submit, then just click the “copy to clipboard” button on the right hand side that should appear when you hover over the SHA-1 hash. Paste this SHA-1 hash into the course web site when you submit your assignment. If you don't want to use the most recent commit, then go down and find the commit you want and copy the SHA-1 hash.